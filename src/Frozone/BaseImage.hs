{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DoAndIfThenElse #-}
module Frozone.BaseImage (ensureBaseImageExists) where

import Frozone.Types
import Frozone.Util.Docker
import Frozone.Util.Process

import System.Exit
import System.FilePath
import System.IO.Temp
import qualified Crypto.Hash.SHA1 as SHA1
import qualified Data.ByteString as BS
import qualified Data.ByteString.Base16 as B16
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.IO as T

ensureBaseImageExists :: RepoConfig -> BS.ByteString -> IO (Either String T.Text)
ensureBaseImageExists repoCfg cabalFile =
    do (ec, stdOut, _) <- runProc "docker" ["images"]
       if ec == ExitSuccess && (T.isInfixOf imageName (T.pack stdOut))
       then return $ Right imageName
       else buildImage
    where
      buildImage =
          withSystemTempDirectory "frozoneDockerBuild" $ \fp ->
              do let baseImage = generateImage repoCfg
                     cabalPkgInstall =
                         [ DockerRun "mkdir -p /cabalpkg"
                         , DockerAdd "cabalfile.cabal" "/cabalpkg/cabalfile.cabal"
                         , DockerRun "cd /cabalpkg && cabal install --only-dependencies"
                         , DockerRun "rm -rf /cabalpkg"
                         ]
                     baseImage' = baseImage { d_cmds = (d_cmds baseImage) ++ cabalPkgInstall }
                     dockerFile = serializeDockerfile baseImage'
                 BS.writeFile (fp </> "cabalfile.cabal") cabalFile
                 T.writeFile (fp </> "Dockerfile") dockerFile
                 (ec, stdout, stderr) <-
                     runProc "docker" ["build", "-rm", "-t", T.unpack imageName, fp]
                 case ec of
                   ExitFailure _ ->
                       return (Left (T.unpack dockerFile ++ "\n\n" ++ stdout ++ "\n\n" ++ stderr))
                   ExitSuccess ->
                       return (Right imageName)
      imageName =
          genImageName repoCfg cabalFile

genImageName :: RepoConfig -> BS.ByteString -> T.Text
genImageName repoCfg cabalFile =
    T.concat ["frozone/base-", hash]
    where
      hash =
          T.decodeUtf8 $
          B16.encode $
          SHA1.hash $
          BS.concat [ cabalFile
                    , T.encodeUtf8 $ T.pack $ show repoCfg
                    ]

generateImage :: RepoConfig -> Dockerfile
generateImage repoCfg =
    Dockerfile
    { d_from = ("ubuntu", Just "14.04")
    , d_maintainer = Just "Generated by Frozone"
    , d_cmds = cmds
    }
    where
      ghcV = rc_ghc repoCfg
      cabalV = rc_cabal repoCfg

      basePkgs =
          [ "supervisor", "emacs", "wget", "make", "git", "darcs", "autoconf", "libtool", "libcairo2-dev", "sqlite3", "libsqlite3-dev"
          , "build-essential", "libedit2", "libglu1-mesa-dev", "libgmp3-dev", "zlib1g-dev", "freeglut3-dev", "ncurses-dev"
          , "libcurl4-gnutls-dev", "subversion"
          ]

      aptPkgs pkgs =
          DockerRun (T.concat ["apt-get install -y ", T.intercalate " " pkgs])

      cmds =
          coreCmds ++ ghcCmds ++ cabalCmds ++ cabalRepoCmds ++ (map (\sh -> DockerRun sh) (rc_shellCmds repoCfg))

      ghcCmds =
          [ DockerRun (T.concat ["wget -O ghc.tar.bz2 http://www.haskell.org/ghc/dist/", ghcV, "/ghc-", ghcV, "-x86_64-unknown-linux.tar.bz2"])
          , DockerRun "tar xvfj ghc.tar.bz2"
          , DockerRun (T.concat ["cd ghc-", ghcV, " && ./configure"])
          , DockerRun (T.concat ["cd ghc-", ghcV, " && make install"])
          , DockerRun (T.concat ["rm -rf ghc.tar.bz2 ghc-", ghcV])
          ]

      cabalCmds =
          [ DockerRun (T.concat ["wget -O cabal.tar.gz http://hackage.haskell.org/package/cabal-install-", cabalV ,"/cabal-install-", cabalV ,".tar.gz"])
          , DockerRun "tar xvfz cabal.tar.gz"
          , DockerRun (T.concat ["cd cabal-install-", cabalV ," && chmod +x ./bootstrap.sh"])
          , DockerRun (T.concat ["cd cabal-install-", cabalV ," && ./bootstrap.sh"])
          , DockerRun (T.concat ["rm -rf cabal-install-", cabalV ," cabal.tar.gz"])
          , DockerEnv "PATH" "/.cabal/bin:$PATH"
          , DockerRun "cabal update"
          ]

      cabalRepoCmds =
          case rc_cabalRepo repoCfg of
            Nothing -> []
            Just repo ->
                let repoUrl = T.replace "/" "\\/" repo
                in [ DockerRun (T.concat ["sed -E 's/(-- )?(remote-repo: ).*/\2frozone:",repoUrl,"/' -i .cabal/config"])
                   , DockerRun "cabal update"
                   ]

      coreCmds =
          [ DockerEnv "DEBIAN_FRONTEND" "noninteractive"
          , DockerRun "locale-gen en_US.UTF-8"
          , DockerEnv "LC_ALL" "en_US.UTF-8"
          , DockerRun "sed 's/main$/main universe/' -i /etc/apt/sources.list"
          , DockerRun "apt-get update"
          , DockerRun "apt-get upgrade -y"
          , aptPkgs basePkgs
          , aptPkgs (rc_aptPkg repoCfg)
            -- libgmp3c2
          , DockerRun "wget -c launchpadlibrarian.net/70575439/libgmp3c2_4.3.2%2Bdfsg-2ubuntu1_amd64.deb"
          , DockerRun "dpkg -i libgmp3c2_4.3.2*.deb"
          ]
